{"ast":null,"code":"\"use strict\";\n\nmodule.exports = ContainerNode;\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\n\n// This class defines common functionality for node subtypes that\n// can have children\n\nfunction ContainerNode() {\n  Node.call(this);\n  this._firstChild = this._childNodes = null;\n}\n\n// Primary representation is a circular linked list of siblings\nContainerNode.prototype = Object.create(Node.prototype, {\n  hasChildNodes: {\n    value: function () {\n      if (this._childNodes) {\n        return this._childNodes.length > 0;\n      }\n      return this._firstChild !== null;\n    }\n  },\n  childNodes: {\n    get: function () {\n      this._ensureChildNodes();\n      return this._childNodes;\n    }\n  },\n  firstChild: {\n    get: function () {\n      if (this._childNodes) {\n        return this._childNodes.length === 0 ? null : this._childNodes[0];\n      }\n      return this._firstChild;\n    }\n  },\n  lastChild: {\n    get: function () {\n      var kids = this._childNodes,\n        first;\n      if (kids) {\n        return kids.length === 0 ? null : kids[kids.length - 1];\n      }\n      first = this._firstChild;\n      if (first === null) {\n        return null;\n      }\n      return first._previousSibling; // circular linked list\n    }\n  },\n\n  _ensureChildNodes: {\n    value: function () {\n      if (this._childNodes) {\n        return;\n      }\n      var first = this._firstChild,\n        kid = first,\n        childNodes = this._childNodes = new NodeList();\n      if (first) do {\n        childNodes.push(kid);\n        kid = kid._nextSibling;\n      } while (kid !== first); // circular linked list\n      this._firstChild = null; // free memory\n    }\n  },\n\n  // Remove all of this node's children.  This is a minor\n  // optimization that only calls modify() once.\n  removeChildren: {\n    value: function removeChildren() {\n      var root = this.rooted ? this.ownerDocument : null,\n        next = this.firstChild,\n        kid;\n      while (next !== null) {\n        kid = next;\n        next = kid.nextSibling;\n        if (root) root.mutateRemove(kid);\n        kid.parentNode = null;\n      }\n      if (this._childNodes) {\n        this._childNodes.length = 0;\n      } else {\n        this._firstChild = null;\n      }\n      this.modify(); // Update last modified type once only\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}