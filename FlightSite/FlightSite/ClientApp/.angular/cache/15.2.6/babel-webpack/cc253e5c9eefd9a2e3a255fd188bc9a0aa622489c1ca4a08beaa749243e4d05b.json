{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Element;\nvar xml = require('./xmlnames');\nvar utils = require('./utils');\nvar NAMESPACE = utils.NAMESPACE;\nvar attributes = require('./attributes');\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\nvar NodeUtils = require('./NodeUtils');\nvar FilteredElementList = require('./FilteredElementList');\nvar DOMException = require('./DOMException');\nvar DOMTokenList = require('./DOMTokenList');\nvar select = require('./select');\nvar ContainerNode = require('./ContainerNode');\nvar ChildNode = require('./ChildNode');\nvar NonDocumentTypeChildNode = require('./NonDocumentTypeChildNode');\nvar NamedNodeMap = require('./NamedNodeMap');\nvar uppercaseCache = Object.create(null);\nfunction Element(doc, localName, namespaceURI, prefix) {\n  ContainerNode.call(this);\n  this.nodeType = Node.ELEMENT_NODE;\n  this.ownerDocument = doc;\n  this.localName = localName;\n  this.namespaceURI = namespaceURI;\n  this.prefix = prefix;\n  this._tagName = undefined;\n\n  // These properties maintain the set of attributes\n  this._attrsByQName = Object.create(null); // The qname->Attr map\n  this._attrsByLName = Object.create(null); // The ns|lname->Attr map\n  this._attrKeys = []; // attr index -> ns|lname\n}\n\nfunction recursiveGetText(node, a) {\n  if (node.nodeType === Node.TEXT_NODE) {\n    a.push(node._data);\n  } else {\n    for (var i = 0, n = node.childNodes.length; i < n; i++) recursiveGetText(node.childNodes[i], a);\n  }\n}\nElement.prototype = Object.create(ContainerNode.prototype, {\n  isHTML: {\n    get: function isHTML() {\n      return this.namespaceURI === NAMESPACE.HTML && this.ownerDocument.isHTML;\n    }\n  },\n  tagName: {\n    get: function tagName() {\n      if (this._tagName === undefined) {\n        var tn;\n        if (this.prefix === null) {\n          tn = this.localName;\n        } else {\n          tn = this.prefix + ':' + this.localName;\n        }\n        if (this.isHTML) {\n          var up = uppercaseCache[tn];\n          if (!up) {\n            // Converting to uppercase can be slow, so cache the conversion.\n            uppercaseCache[tn] = up = utils.toASCIIUpperCase(tn);\n          }\n          tn = up;\n        }\n        this._tagName = tn;\n      }\n      return this._tagName;\n    }\n  },\n  nodeName: {\n    get: function () {\n      return this.tagName;\n    }\n  },\n  nodeValue: {\n    get: function () {\n      return null;\n    },\n    set: function () {}\n  },\n  textContent: {\n    get: function () {\n      var strings = [];\n      recursiveGetText(this, strings);\n      return strings.join('');\n    },\n    set: function (newtext) {\n      this.removeChildren();\n      if (newtext !== null && newtext !== undefined && newtext !== '') {\n        this._appendChild(this.ownerDocument.createTextNode(newtext));\n      }\n    }\n  },\n  innerHTML: {\n    get: function () {\n      return this.serialize();\n    },\n    set: utils.nyi\n  },\n  outerHTML: {\n    get: function () {\n      // \"the attribute must return the result of running the HTML fragment\n      // serialization algorithm on a fictional node whose only child is\n      // the context object\"\n      //\n      // The serialization logic is intentionally implemented in a separate\n      // `NodeUtils` helper instead of the more obvious choice of a private\n      // `_serializeOne()` method on the `Node.prototype` in order to avoid\n      // the megamorphic `this._serializeOne` property access, which reduces\n      // performance unnecessarily. If you need specialized behavior for a\n      // certain subclass, you'll need to implement that in `NodeUtils`.\n      // See https://github.com/fgnass/domino/pull/142 for more information.\n      return NodeUtils.serializeOne(this, {\n        nodeType: 0\n      });\n    },\n    set: function (v) {\n      var document = this.ownerDocument;\n      var parent = this.parentNode;\n      if (parent === null) {\n        return;\n      }\n      if (parent.nodeType === Node.DOCUMENT_NODE) {\n        utils.NoModificationAllowedError();\n      }\n      if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        parent = parent.ownerDocument.createElement(\"body\");\n      }\n      var parser = document.implementation.mozHTMLParser(document._address, parent);\n      parser.parse(v === null ? '' : String(v), true);\n      this.replaceWith(parser._asDocumentFragment());\n    }\n  },\n  _insertAdjacent: {\n    value: function _insertAdjacent(position, node) {\n      var first = false;\n      switch (position) {\n        case 'beforebegin':\n          first = true;\n        /* falls through */\n        case 'afterend':\n          var parent = this.parentNode;\n          if (parent === null) {\n            return null;\n          }\n          return parent.insertBefore(node, first ? this : this.nextSibling);\n        case 'afterbegin':\n          first = true;\n        /* falls through */\n        case 'beforeend':\n          return this.insertBefore(node, first ? this.firstChild : null);\n        default:\n          return utils.SyntaxError();\n      }\n    }\n  },\n  insertAdjacentElement: {\n    value: function insertAdjacentElement(position, element) {\n      if (element.nodeType !== Node.ELEMENT_NODE) {\n        throw new TypeError('not an element');\n      }\n      position = utils.toASCIILowerCase(String(position));\n      return this._insertAdjacent(position, element);\n    }\n  },\n  insertAdjacentText: {\n    value: function insertAdjacentText(position, data) {\n      var textNode = this.ownerDocument.createTextNode(data);\n      position = utils.toASCIILowerCase(String(position));\n      this._insertAdjacent(position, textNode);\n      // \"This method returns nothing because it existed before we had a chance\n      // to design it.\"\n    }\n  },\n\n  insertAdjacentHTML: {\n    value: function insertAdjacentHTML(position, text) {\n      position = utils.toASCIILowerCase(String(position));\n      text = String(text);\n      var context;\n      switch (position) {\n        case 'beforebegin':\n        case 'afterend':\n          context = this.parentNode;\n          if (context === null || context.nodeType === Node.DOCUMENT_NODE) {\n            utils.NoModificationAllowedError();\n          }\n          break;\n        case 'afterbegin':\n        case 'beforeend':\n          context = this;\n          break;\n        default:\n          utils.SyntaxError();\n      }\n      if (!(context instanceof Element) || context.ownerDocument.isHTML && context.localName === 'html' && context.namespaceURI === NAMESPACE.HTML) {\n        context = context.ownerDocument.createElementNS(NAMESPACE.HTML, 'body');\n      }\n      var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, context);\n      parser.parse(text, true);\n      this._insertAdjacent(position, parser._asDocumentFragment());\n    }\n  },\n  children: {\n    get: function () {\n      if (!this._children) {\n        this._children = new ChildrenCollection(this);\n      }\n      return this._children;\n    }\n  },\n  attributes: {\n    get: function () {\n      if (!this._attributes) {\n        this._attributes = new AttributesArray(this);\n      }\n      return this._attributes;\n    }\n  },\n  firstElementChild: {\n    get: function () {\n      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n        if (kid.nodeType === Node.ELEMENT_NODE) return kid;\n      }\n      return null;\n    }\n  },\n  lastElementChild: {\n    get: function () {\n      for (var kid = this.lastChild; kid !== null; kid = kid.previousSibling) {\n        if (kid.nodeType === Node.ELEMENT_NODE) return kid;\n      }\n      return null;\n    }\n  },\n  childElementCount: {\n    get: function () {\n      return this.children.length;\n    }\n  },\n  // Return the next element, in source order, after this one or\n  // null if there are no more.  If root element is specified,\n  // then don't traverse beyond its subtree.\n  //\n  // This is not a DOM method, but is convenient for\n  // lazy traversals of the tree.\n  nextElement: {\n    value: function (root) {\n      if (!root) root = this.ownerDocument.documentElement;\n      var next = this.firstElementChild;\n      if (!next) {\n        // don't use sibling if we're at root\n        if (this === root) return null;\n        next = this.nextElementSibling;\n      }\n      if (next) return next;\n\n      // If we can't go down or across, then we have to go up\n      // and across to the parent sibling or another ancestor's\n      // sibling.  Be careful, though: if we reach the root\n      // element, or if we reach the documentElement, then\n      // the traversal ends.\n      for (var parent = this.parentElement; parent && parent !== root; parent = parent.parentElement) {\n        next = parent.nextElementSibling;\n        if (next) return next;\n      }\n      return null;\n    }\n  },\n  // XXX:\n  // Tests are currently failing for this function.\n  // Awaiting resolution of:\n  // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html\n  getElementsByTagName: {\n    value: function getElementsByTagName(lname) {\n      var filter;\n      if (!lname) return new NodeList();\n      if (lname === '*') filter = function () {\n        return true;\n      };else if (this.isHTML) filter = htmlLocalNameElementFilter(lname);else filter = localNameElementFilter(lname);\n      return new FilteredElementList(this, filter);\n    }\n  },\n  getElementsByTagNameNS: {\n    value: function getElementsByTagNameNS(ns, lname) {\n      var filter;\n      if (ns === '*' && lname === '*') filter = function () {\n        return true;\n      };else if (ns === '*') filter = localNameElementFilter(lname);else if (lname === '*') filter = namespaceElementFilter(ns);else filter = namespaceLocalNameElementFilter(ns, lname);\n      return new FilteredElementList(this, filter);\n    }\n  },\n  getElementsByClassName: {\n    value: function getElementsByClassName(names) {\n      names = String(names).trim();\n      if (names === '') {\n        var result = new NodeList(); // Empty node list\n        return result;\n      }\n      names = names.split(/[ \\t\\r\\n\\f]+/); // Split on ASCII whitespace\n      return new FilteredElementList(this, classNamesElementFilter(names));\n    }\n  },\n  getElementsByName: {\n    value: function getElementsByName(name) {\n      return new FilteredElementList(this, elementNameFilter(String(name)));\n    }\n  },\n  // Utility methods used by the public API methods above\n  clone: {\n    value: function clone() {\n      var e;\n\n      // XXX:\n      // Modify this to use the constructor directly or\n      // avoid error checking in some other way. In case we try\n      // to clone an invalid node that the parser inserted.\n      //\n      if (this.namespaceURI !== NAMESPACE.HTML || this.prefix || !this.ownerDocument.isHTML) {\n        e = this.ownerDocument.createElementNS(this.namespaceURI, this.prefix !== null ? this.prefix + ':' + this.localName : this.localName);\n      } else {\n        e = this.ownerDocument.createElement(this.localName);\n      }\n      for (var i = 0, n = this._attrKeys.length; i < n; i++) {\n        var lname = this._attrKeys[i];\n        var a = this._attrsByLName[lname];\n        var b = a.cloneNode();\n        b._setOwnerElement(e);\n        e._attrsByLName[lname] = b;\n        e._addQName(b);\n      }\n      e._attrKeys = this._attrKeys.concat();\n      return e;\n    }\n  },\n  isEqual: {\n    value: function isEqual(that) {\n      if (this.localName !== that.localName || this.namespaceURI !== that.namespaceURI || this.prefix !== that.prefix || this._numattrs !== that._numattrs) return false;\n\n      // Compare the sets of attributes, ignoring order\n      // and ignoring attribute prefixes.\n      for (var i = 0, n = this._numattrs; i < n; i++) {\n        var a = this._attr(i);\n        if (!that.hasAttributeNS(a.namespaceURI, a.localName)) return false;\n        if (that.getAttributeNS(a.namespaceURI, a.localName) !== a.value) return false;\n      }\n      return true;\n    }\n  },\n  // This is the 'locate a namespace prefix' algorithm from the\n  // DOM specification.  It is used by Node.lookupPrefix()\n  // (Be sure to compare DOM3 and DOM4 versions of spec.)\n  _lookupNamespacePrefix: {\n    value: function _lookupNamespacePrefix(ns, originalElement) {\n      if (this.namespaceURI && this.namespaceURI === ns && this.prefix !== null && originalElement.lookupNamespaceURI(this.prefix) === ns) {\n        return this.prefix;\n      }\n      for (var i = 0, n = this._numattrs; i < n; i++) {\n        var a = this._attr(i);\n        if (a.prefix === 'xmlns' && a.value === ns && originalElement.lookupNamespaceURI(a.localName) === ns) {\n          return a.localName;\n        }\n      }\n      var parent = this.parentElement;\n      return parent ? parent._lookupNamespacePrefix(ns, originalElement) : null;\n    }\n  },\n  // This is the 'locate a namespace' algorithm for Element nodes\n  // from the DOM Core spec.  It is used by Node#lookupNamespaceURI()\n  lookupNamespaceURI: {\n    value: function lookupNamespaceURI(prefix) {\n      if (prefix === '' || prefix === undefined) {\n        prefix = null;\n      }\n      if (this.namespaceURI !== null && this.prefix === prefix) return this.namespaceURI;\n      for (var i = 0, n = this._numattrs; i < n; i++) {\n        var a = this._attr(i);\n        if (a.namespaceURI === NAMESPACE.XMLNS) {\n          if (a.prefix === 'xmlns' && a.localName === prefix || prefix === null && a.prefix === null && a.localName === 'xmlns') {\n            return a.value || null;\n          }\n        }\n      }\n      var parent = this.parentElement;\n      return parent ? parent.lookupNamespaceURI(prefix) : null;\n    }\n  },\n  //\n  // Attribute handling methods and utilities\n  //\n\n  /*\n   * Attributes in the DOM are tricky:\n   *\n   * - there are the 8 basic get/set/has/removeAttribute{NS} methods\n   *\n   * - but many HTML attributes are also 'reflected' through IDL\n   *   attributes which means that they can be queried and set through\n   *   regular properties of the element.  There is just one attribute\n   *   value, but two ways to get and set it.\n   *\n   * - Different HTML element types have different sets of reflected\n     attributes.\n   *\n   * - attributes can also be queried and set through the .attributes\n   *   property of an element.  This property behaves like an array of\n   *   Attr objects.  The value property of each Attr is writeable, so\n   *   this is a third way to read and write attributes.\n   *\n   * - for efficiency, we really want to store attributes in some kind\n   *   of name->attr map.  But the attributes[] array is an array, not a\n   *   map, which is kind of unnatural.\n   *\n   * - When using namespaces and prefixes, and mixing the NS methods\n   *   with the non-NS methods, it is apparently actually possible for\n   *   an attributes[] array to have more than one attribute with the\n   *   same qualified name.  And certain methods must operate on only\n   *   the first attribute with such a name.  So for these methods, an\n   *   inefficient array-like data structure would be easier to\n   *   implement.\n   *\n   * - The attributes[] array is live, not a snapshot, so changes to the\n   *   attributes must be immediately visible through existing arrays.\n   *\n   * - When attributes are queried and set through IDL properties\n   *   (instead of the get/setAttributes() method or the attributes[]\n   *   array) they may be subject to type conversions, URL\n   *   normalization, etc., so some extra processing is required in that\n   *   case.\n   *\n   * - But access through IDL properties is probably the most common\n   *   case, so we'd like that to be as fast as possible.\n   *\n   * - We can't just store attribute values in their parsed idl form,\n   *   because setAttribute() has to return whatever string is passed to\n   *   getAttribute even if it is not a legal, parseable value. So\n   *   attribute values must be stored in unparsed string form.\n   *\n   * - We need to be able to send change notifications or mutation\n   *   events of some sort to the renderer whenever an attribute value\n   *   changes, regardless of the way in which it changes.\n   *\n   * - Some attributes, such as id and class affect other parts of the\n   *   DOM API, like getElementById and getElementsByClassName and so\n   *   for efficiency, we need to specially track changes to these\n   *   special attributes.\n   *\n   * - Some attributes like class have different names (className) when\n   *   reflected.\n   *\n   * - Attributes whose names begin with the string 'data-' are treated\n     specially.\n   *\n   * - Reflected attributes that have a boolean type in IDL have special\n   *   behavior: setting them to false (in IDL) is the same as removing\n   *   them with removeAttribute()\n   *\n   * - numeric attributes (like HTMLElement.tabIndex) can have default\n   *   values that must be returned by the idl getter even if the\n   *   content attribute does not exist. (The default tabIndex value\n   *   actually varies based on the type of the element, so that is a\n   *   tricky one).\n   *\n   * See\n   * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect\n   * for rules on how attributes are reflected.\n   *\n   */\n\n  getAttribute: {\n    value: function getAttribute(qname) {\n      var attr = this.getAttributeNode(qname);\n      return attr ? attr.value : null;\n    }\n  },\n  getAttributeNS: {\n    value: function getAttributeNS(ns, lname) {\n      var attr = this.getAttributeNodeNS(ns, lname);\n      return attr ? attr.value : null;\n    }\n  },\n  getAttributeNode: {\n    value: function getAttributeNode(qname) {\n      qname = String(qname);\n      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);\n      var attr = this._attrsByQName[qname];\n      if (!attr) return null;\n      if (Array.isArray(attr))\n        // If there is more than one\n        attr = attr[0]; // use the first\n\n      return attr;\n    }\n  },\n  getAttributeNodeNS: {\n    value: function getAttributeNodeNS(ns, lname) {\n      ns = ns === undefined || ns === null ? '' : String(ns);\n      lname = String(lname);\n      var attr = this._attrsByLName[ns + '|' + lname];\n      return attr ? attr : null;\n    }\n  },\n  hasAttribute: {\n    value: function hasAttribute(qname) {\n      qname = String(qname);\n      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);\n      return this._attrsByQName[qname] !== undefined;\n    }\n  },\n  hasAttributeNS: {\n    value: function hasAttributeNS(ns, lname) {\n      ns = ns === undefined || ns === null ? '' : String(ns);\n      lname = String(lname);\n      var key = ns + '|' + lname;\n      return this._attrsByLName[key] !== undefined;\n    }\n  },\n  hasAttributes: {\n    value: function hasAttributes() {\n      return this._numattrs > 0;\n    }\n  },\n  toggleAttribute: {\n    value: function toggleAttribute(qname, force) {\n      qname = String(qname);\n      if (!xml.isValidName(qname)) utils.InvalidCharacterError();\n      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);\n      var a = this._attrsByQName[qname];\n      if (a === undefined) {\n        if (force === undefined || force === true) {\n          this._setAttribute(qname, '');\n          return true;\n        }\n        return false;\n      } else {\n        if (force === undefined || force === false) {\n          this.removeAttribute(qname);\n          return false;\n        }\n        return true;\n      }\n    }\n  },\n  // Set the attribute without error checking. The parser uses this.\n  _setAttribute: {\n    value: function _setAttribute(qname, value) {\n      // XXX: the spec says that this next search should be done\n      // on the local name, but I think that is an error.\n      // email pending on www-dom about it.\n      var attr = this._attrsByQName[qname];\n      var isnew;\n      if (!attr) {\n        attr = this._newattr(qname);\n        isnew = true;\n      } else {\n        if (Array.isArray(attr)) attr = attr[0];\n      }\n\n      // Now set the attribute value on the new or existing Attr object.\n      // The Attr.value setter method handles mutation events, etc.\n      attr.value = value;\n      if (this._attributes) this._attributes[qname] = attr;\n      if (isnew && this._newattrhook) this._newattrhook(qname, value);\n    }\n  },\n  // Check for errors, and then set the attribute\n  setAttribute: {\n    value: function setAttribute(qname, value) {\n      qname = String(qname);\n      if (!xml.isValidName(qname)) utils.InvalidCharacterError();\n      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);\n      this._setAttribute(qname, String(value));\n    }\n  },\n  // The version with no error checking used by the parser\n  _setAttributeNS: {\n    value: function _setAttributeNS(ns, qname, value) {\n      var pos = qname.indexOf(':'),\n        prefix,\n        lname;\n      if (pos < 0) {\n        prefix = null;\n        lname = qname;\n      } else {\n        prefix = qname.substring(0, pos);\n        lname = qname.substring(pos + 1);\n      }\n      if (ns === '' || ns === undefined) ns = null;\n      var key = (ns === null ? '' : ns) + '|' + lname;\n      var attr = this._attrsByLName[key];\n      var isnew;\n      if (!attr) {\n        attr = new Attr(this, lname, prefix, ns);\n        isnew = true;\n        this._attrsByLName[key] = attr;\n        if (this._attributes) {\n          this._attributes[this._attrKeys.length] = attr;\n        }\n        this._attrKeys.push(key);\n\n        // We also have to make the attr searchable by qname.\n        // But we have to be careful because there may already\n        // be an attr with this qname.\n        this._addQName(attr);\n      } else if (false /* changed in DOM 4 */) {\n        // Calling setAttributeNS() can change the prefix of an\n        // existing attribute in DOM 2/3.\n        if (attr.prefix !== prefix) {\n          // Unbind the old qname\n          this._removeQName(attr);\n          // Update the prefix\n          attr.prefix = prefix;\n          // Bind the new qname\n          this._addQName(attr);\n        }\n      }\n      attr.value = value; // Automatically sends mutation event\n      if (isnew && this._newattrhook) this._newattrhook(qname, value);\n    }\n  },\n  // Do error checking then call _setAttributeNS\n  setAttributeNS: {\n    value: function setAttributeNS(ns, qname, value) {\n      // Convert parameter types according to WebIDL\n      ns = ns === null || ns === undefined || ns === '' ? null : String(ns);\n      qname = String(qname);\n      if (!xml.isValidQName(qname)) utils.InvalidCharacterError();\n      var pos = qname.indexOf(':');\n      var prefix = pos < 0 ? null : qname.substring(0, pos);\n      if (prefix !== null && ns === null || prefix === 'xml' && ns !== NAMESPACE.XML || (qname === 'xmlns' || prefix === 'xmlns') && ns !== NAMESPACE.XMLNS || ns === NAMESPACE.XMLNS && !(qname === 'xmlns' || prefix === 'xmlns')) utils.NamespaceError();\n      this._setAttributeNS(ns, qname, String(value));\n    }\n  },\n  setAttributeNode: {\n    value: function setAttributeNode(attr) {\n      if (attr.ownerElement !== null && attr.ownerElement !== this) {\n        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n      }\n      var result = null;\n      var oldAttrs = this._attrsByQName[attr.name];\n      if (oldAttrs) {\n        if (!Array.isArray(oldAttrs)) {\n          oldAttrs = [oldAttrs];\n        }\n        if (oldAttrs.some(function (a) {\n          return a === attr;\n        })) {\n          return attr;\n        } else if (attr.ownerElement !== null) {\n          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n        }\n        oldAttrs.forEach(function (a) {\n          this.removeAttributeNode(a);\n        }, this);\n        result = oldAttrs[0];\n      }\n      this.setAttributeNodeNS(attr);\n      return result;\n    }\n  },\n  setAttributeNodeNS: {\n    value: function setAttributeNodeNS(attr) {\n      if (attr.ownerElement !== null) {\n        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n      }\n      var ns = attr.namespaceURI;\n      var key = (ns === null ? '' : ns) + '|' + attr.localName;\n      var oldAttr = this._attrsByLName[key];\n      if (oldAttr) {\n        this.removeAttributeNode(oldAttr);\n      }\n      attr._setOwnerElement(this);\n      this._attrsByLName[key] = attr;\n      if (this._attributes) {\n        this._attributes[this._attrKeys.length] = attr;\n      }\n      this._attrKeys.push(key);\n      this._addQName(attr);\n      if (this._newattrhook) this._newattrhook(attr.name, attr.value);\n      return oldAttr || null;\n    }\n  },\n  removeAttribute: {\n    value: function removeAttribute(qname) {\n      qname = String(qname);\n      if (/[A-Z]/.test(qname) && this.isHTML) qname = utils.toASCIILowerCase(qname);\n      var attr = this._attrsByQName[qname];\n      if (!attr) return;\n\n      // If there is more than one match for this qname\n      // so don't delete the qname mapping, just remove the first\n      // element from it.\n      if (Array.isArray(attr)) {\n        if (attr.length > 2) {\n          attr = attr.shift(); // remove it from the array\n        } else {\n          this._attrsByQName[qname] = attr[1];\n          attr = attr[0];\n        }\n      } else {\n        // only a single match, so remove the qname mapping\n        this._attrsByQName[qname] = undefined;\n      }\n      var ns = attr.namespaceURI;\n      // Now attr is the removed attribute.  Figure out its\n      // ns+lname key and remove it from the other mapping as well.\n      var key = (ns === null ? '' : ns) + '|' + attr.localName;\n      this._attrsByLName[key] = undefined;\n      var i = this._attrKeys.indexOf(key);\n      if (this._attributes) {\n        Array.prototype.splice.call(this._attributes, i, 1);\n        this._attributes[qname] = undefined;\n      }\n      this._attrKeys.splice(i, 1);\n\n      // Onchange handler for the attribute\n      var onchange = attr.onchange;\n      attr._setOwnerElement(null);\n      if (onchange) {\n        onchange.call(attr, this, attr.localName, attr.value, null);\n      }\n      // Mutation event\n      if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);\n    }\n  },\n  removeAttributeNS: {\n    value: function removeAttributeNS(ns, lname) {\n      ns = ns === undefined || ns === null ? '' : String(ns);\n      lname = String(lname);\n      var key = ns + '|' + lname;\n      var attr = this._attrsByLName[key];\n      if (!attr) return;\n      this._attrsByLName[key] = undefined;\n      var i = this._attrKeys.indexOf(key);\n      if (this._attributes) {\n        Array.prototype.splice.call(this._attributes, i, 1);\n      }\n      this._attrKeys.splice(i, 1);\n\n      // Now find the same Attr object in the qname mapping and remove it\n      // But be careful because there may be more than one match.\n      this._removeQName(attr);\n\n      // Onchange handler for the attribute\n      var onchange = attr.onchange;\n      attr._setOwnerElement(null);\n      if (onchange) {\n        onchange.call(attr, this, attr.localName, attr.value, null);\n      }\n      // Mutation event\n      if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);\n    }\n  },\n  removeAttributeNode: {\n    value: function removeAttributeNode(attr) {\n      var ns = attr.namespaceURI;\n      var key = (ns === null ? '' : ns) + '|' + attr.localName;\n      if (this._attrsByLName[key] !== attr) {\n        utils.NotFoundError();\n      }\n      this.removeAttributeNS(ns, attr.localName);\n      return attr;\n    }\n  },\n  getAttributeNames: {\n    value: function getAttributeNames() {\n      var elt = this;\n      return this._attrKeys.map(function (key) {\n        return elt._attrsByLName[key].name;\n      });\n    }\n  },\n  // This 'raw' version of getAttribute is used by the getter functions\n  // of reflected attributes. It skips some error checking and\n  // namespace steps\n  _getattr: {\n    value: function _getattr(qname) {\n      // Assume that qname is already lowercased, so don't do it here.\n      // Also don't check whether attr is an array: a qname with no\n      // prefix will never have two matching Attr objects (because\n      // setAttributeNS doesn't allow a non-null namespace with a\n      // null prefix.\n      var attr = this._attrsByQName[qname];\n      return attr ? attr.value : null;\n    }\n  },\n  // The raw version of setAttribute for reflected idl attributes.\n  _setattr: {\n    value: function _setattr(qname, value) {\n      var attr = this._attrsByQName[qname];\n      var isnew;\n      if (!attr) {\n        attr = this._newattr(qname);\n        isnew = true;\n      }\n      attr.value = String(value);\n      if (this._attributes) this._attributes[qname] = attr;\n      if (isnew && this._newattrhook) this._newattrhook(qname, value);\n    }\n  },\n  // Create a new Attr object, insert it, and return it.\n  // Used by setAttribute() and by set()\n  _newattr: {\n    value: function _newattr(qname) {\n      var attr = new Attr(this, qname, null, null);\n      var key = '|' + qname;\n      this._attrsByQName[qname] = attr;\n      this._attrsByLName[key] = attr;\n      if (this._attributes) {\n        this._attributes[this._attrKeys.length] = attr;\n      }\n      this._attrKeys.push(key);\n      return attr;\n    }\n  },\n  // Add a qname->Attr mapping to the _attrsByQName object, taking into\n  // account that there may be more than one attr object with the\n  // same qname\n  _addQName: {\n    value: function (attr) {\n      var qname = attr.name;\n      var existing = this._attrsByQName[qname];\n      if (!existing) {\n        this._attrsByQName[qname] = attr;\n      } else if (Array.isArray(existing)) {\n        existing.push(attr);\n      } else {\n        this._attrsByQName[qname] = [existing, attr];\n      }\n      if (this._attributes) this._attributes[qname] = attr;\n    }\n  },\n  // Remove a qname->Attr mapping to the _attrsByQName object, taking into\n  // account that there may be more than one attr object with the\n  // same qname\n  _removeQName: {\n    value: function (attr) {\n      var qname = attr.name;\n      var target = this._attrsByQName[qname];\n      if (Array.isArray(target)) {\n        var idx = target.indexOf(attr);\n        utils.assert(idx !== -1); // It must be here somewhere\n        if (target.length === 2) {\n          this._attrsByQName[qname] = target[1 - idx];\n          if (this._attributes) {\n            this._attributes[qname] = this._attrsByQName[qname];\n          }\n        } else {\n          target.splice(idx, 1);\n          if (this._attributes && this._attributes[qname] === attr) {\n            this._attributes[qname] = target[0];\n          }\n        }\n      } else {\n        utils.assert(target === attr); // If only one, it must match\n        this._attrsByQName[qname] = undefined;\n        if (this._attributes) {\n          this._attributes[qname] = undefined;\n        }\n      }\n    }\n  },\n  // Return the number of attributes\n  _numattrs: {\n    get: function () {\n      return this._attrKeys.length;\n    }\n  },\n  // Return the nth Attr object\n  _attr: {\n    value: function (n) {\n      return this._attrsByLName[this._attrKeys[n]];\n    }\n  },\n  // Define getters and setters for an 'id' property that reflects\n  // the content attribute 'id'.\n  id: attributes.property({\n    name: 'id'\n  }),\n  // Define getters and setters for a 'className' property that reflects\n  // the content attribute 'class'.\n  className: attributes.property({\n    name: 'class'\n  }),\n  classList: {\n    get: function () {\n      var self = this;\n      if (this._classList) {\n        return this._classList;\n      }\n      var dtlist = new DOMTokenList(function () {\n        return self.className || \"\";\n      }, function (v) {\n        self.className = v;\n      });\n      this._classList = dtlist;\n      return dtlist;\n    },\n    set: function (v) {\n      this.className = v;\n    }\n  },\n  matches: {\n    value: function (selector) {\n      return select.matches(this, selector);\n    }\n  },\n  closest: {\n    value: function (selector) {\n      var el = this;\n      do {\n        if (el.matches && el.matches(selector)) {\n          return el;\n        }\n        el = el.parentElement || el.parentNode;\n      } while (el !== null && el.nodeType === Node.ELEMENT_NODE);\n      return null;\n    }\n  },\n  querySelector: {\n    value: function (selector) {\n      return select(selector, this)[0];\n    }\n  },\n  querySelectorAll: {\n    value: function (selector) {\n      var nodes = select(selector, this);\n      return nodes.item ? nodes : new NodeList(nodes);\n    }\n  }\n});\nObject.defineProperties(Element.prototype, ChildNode);\nObject.defineProperties(Element.prototype, NonDocumentTypeChildNode);\n\n// Register special handling for the id attribute\nattributes.registerChangeHandler(Element, 'id', function (element, lname, oldval, newval) {\n  if (element.rooted) {\n    if (oldval) {\n      element.ownerDocument.delId(oldval, element);\n    }\n    if (newval) {\n      element.ownerDocument.addId(newval, element);\n    }\n  }\n});\nattributes.registerChangeHandler(Element, 'class', function (element, lname, oldval, newval) {\n  if (element._classList) {\n    element._classList._update();\n  }\n});\n\n// The Attr class represents a single attribute.  The values in\n// _attrsByQName and _attrsByLName are instances of this class.\nfunction Attr(elt, lname, prefix, namespace, value) {\n  // localName and namespace are constant for any attr object.\n  // But value may change.  And so can prefix, and so, therefore can name.\n  this.localName = lname;\n  this.prefix = prefix === null || prefix === '' ? null : '' + prefix;\n  this.namespaceURI = namespace === null || namespace === '' ? null : '' + namespace;\n  this.data = value;\n  // Set ownerElement last to ensure it is hooked up to onchange handler\n  this._setOwnerElement(elt);\n}\n\n// In DOM 3 Attr was supposed to extend Node; in DOM 4 that was abandoned.\nAttr.prototype = Object.create(Object.prototype, {\n  ownerElement: {\n    get: function () {\n      return this._ownerElement;\n    }\n  },\n  _setOwnerElement: {\n    value: function _setOwnerElement(elt) {\n      this._ownerElement = elt;\n      if (this.prefix === null && this.namespaceURI === null && elt) {\n        this.onchange = elt._attributeChangeHandlers[this.localName];\n      } else {\n        this.onchange = null;\n      }\n    }\n  },\n  name: {\n    get: function () {\n      return this.prefix ? this.prefix + ':' + this.localName : this.localName;\n    }\n  },\n  specified: {\n    get: function () {\n      // Deprecated\n      return true;\n    }\n  },\n  value: {\n    get: function () {\n      return this.data;\n    },\n    set: function (value) {\n      var oldval = this.data;\n      value = value === undefined ? '' : value + '';\n      if (value === oldval) return;\n      this.data = value;\n\n      // Run the onchange hook for the attribute\n      // if there is one.\n      if (this.ownerElement) {\n        if (this.onchange) this.onchange(this.ownerElement, this.localName, oldval, value);\n\n        // Generate a mutation event if the element is rooted\n        if (this.ownerElement.rooted) this.ownerElement.ownerDocument.mutateAttr(this, oldval);\n      }\n    }\n  },\n  cloneNode: {\n    value: function cloneNode(deep) {\n      // Both this method and Document#createAttribute*() create unowned Attrs\n      return new Attr(null, this.localName, this.prefix, this.namespaceURI, this.data);\n    }\n  },\n  // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)\n  nodeType: {\n    get: function () {\n      return Node.ATTRIBUTE_NODE;\n    }\n  },\n  nodeName: {\n    get: function () {\n      return this.name;\n    }\n  },\n  nodeValue: {\n    get: function () {\n      return this.value;\n    },\n    set: function (v) {\n      this.value = v;\n    }\n  },\n  textContent: {\n    get: function () {\n      return this.value;\n    },\n    set: function (v) {\n      if (v === null || v === undefined) {\n        v = '';\n      }\n      this.value = v;\n    }\n  }\n});\n// Sneakily export this class for use by Document.createAttribute()\nElement._Attr = Attr;\n\n// The attributes property of an Element will be an instance of this class.\n// This class is really just a dummy, though. It only defines a length\n// property and an item() method. The AttrArrayProxy that\n// defines the public API just uses the Element object itself.\nfunction AttributesArray(elt) {\n  NamedNodeMap.call(this, elt);\n  for (var name in elt._attrsByQName) {\n    this[name] = elt._attrsByQName[name];\n  }\n  for (var i = 0; i < elt._attrKeys.length; i++) {\n    this[i] = elt._attrsByLName[elt._attrKeys[i]];\n  }\n}\nAttributesArray.prototype = Object.create(NamedNodeMap.prototype, {\n  length: {\n    get: function () {\n      return this.element._attrKeys.length;\n    },\n    set: function () {/* ignore */}\n  },\n  item: {\n    value: function (n) {\n      /* jshint bitwise: false */\n      n = n >>> 0;\n      if (n >= this.length) {\n        return null;\n      }\n      return this.element._attrsByLName[this.element._attrKeys[n]];\n      /* jshint bitwise: true */\n    }\n  }\n});\n\n// We can't make direct array access work (without Proxies, node >=6)\n// but we can make `Array.from(node.attributes)` and for-of loops work.\nif (global.Symbol && global.Symbol.iterator) {\n  AttributesArray.prototype[global.Symbol.iterator] = function () {\n    var i = 0,\n      n = this.length,\n      self = this;\n    return {\n      next: function () {\n        if (i < n) return {\n          value: self.item(i++)\n        };\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n// The children property of an Element will be an instance of this class.\n// It defines length, item() and namedItem() and will be wrapped by an\n// HTMLCollection when exposed through the DOM.\nfunction ChildrenCollection(e) {\n  this.element = e;\n  this.updateCache();\n}\nChildrenCollection.prototype = Object.create(Object.prototype, {\n  length: {\n    get: function () {\n      this.updateCache();\n      return this.childrenByNumber.length;\n    }\n  },\n  item: {\n    value: function item(n) {\n      this.updateCache();\n      return this.childrenByNumber[n] || null;\n    }\n  },\n  namedItem: {\n    value: function namedItem(name) {\n      this.updateCache();\n      return this.childrenByName[name] || null;\n    }\n  },\n  // This attribute returns the entire name->element map.\n  // It is not part of the HTMLCollection API, but we need it in\n  // src/HTMLCollectionProxy\n  namedItems: {\n    get: function () {\n      this.updateCache();\n      return this.childrenByName;\n    }\n  },\n  updateCache: {\n    value: function updateCache() {\n      var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;\n      if (this.lastModTime !== this.element.lastModTime) {\n        this.lastModTime = this.element.lastModTime;\n        var n = this.childrenByNumber && this.childrenByNumber.length || 0;\n        for (var i = 0; i < n; i++) {\n          this[i] = undefined;\n        }\n        this.childrenByNumber = [];\n        this.childrenByName = Object.create(null);\n        for (var c = this.element.firstChild; c !== null; c = c.nextSibling) {\n          if (c.nodeType === Node.ELEMENT_NODE) {\n            this[this.childrenByNumber.length] = c;\n            this.childrenByNumber.push(c);\n\n            // XXX Are there any requirements about the namespace\n            // of the id property?\n            var id = c.getAttribute('id');\n\n            // If there is an id that is not already in use...\n            if (id && !this.childrenByName[id]) this.childrenByName[id] = c;\n\n            // For certain HTML elements we check the name attribute\n            var name = c.getAttribute('name');\n            if (name && this.element.namespaceURI === NAMESPACE.HTML && namedElts.test(this.element.localName) && !this.childrenByName[name]) this.childrenByName[id] = c;\n          }\n        }\n      }\n    }\n  }\n});\n\n// These functions return predicates for filtering elements.\n// They're used by the Document and Element classes for methods like\n// getElementsByTagName and getElementsByClassName\n\nfunction localNameElementFilter(lname) {\n  return function (e) {\n    return e.localName === lname;\n  };\n}\nfunction htmlLocalNameElementFilter(lname) {\n  var lclname = utils.toASCIILowerCase(lname);\n  if (lclname === lname) return localNameElementFilter(lname);\n  return function (e) {\n    return e.isHTML ? e.localName === lclname : e.localName === lname;\n  };\n}\nfunction namespaceElementFilter(ns) {\n  return function (e) {\n    return e.namespaceURI === ns;\n  };\n}\nfunction namespaceLocalNameElementFilter(ns, lname) {\n  return function (e) {\n    return e.namespaceURI === ns && e.localName === lname;\n  };\n}\nfunction classNamesElementFilter(names) {\n  return function (e) {\n    return names.every(function (n) {\n      return e.classList.contains(n);\n    });\n  };\n}\nfunction elementNameFilter(name) {\n  return function (e) {\n    // All the *HTML elements* in the document with the given name attribute\n    if (e.namespaceURI !== NAMESPACE.HTML) {\n      return false;\n    }\n    return e.getAttribute('name') === name;\n  };\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}