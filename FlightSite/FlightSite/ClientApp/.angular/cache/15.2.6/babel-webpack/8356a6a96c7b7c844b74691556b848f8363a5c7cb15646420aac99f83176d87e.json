{"ast":null,"code":"/**\n * @license Angular v15.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ɵsetRootDomAdapter, DOCUMENT, XhrFactory, PlatformLocation, ɵgetDOM, ɵPLATFORM_SERVER_ID, ViewportScroller, ɵNullViewportScroller } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, InjectionToken, inject, EnvironmentInjector, Optional, ViewEncapsulation, RendererStyleFlags2, APP_ID, NgModule, Injector, PLATFORM_ID, PLATFORM_INITIALIZER, ɵALLOW_MULTIPLE_PLATFORMS, RendererFactory2, NgZone, Testability, ɵTESTABILITY, ɵsetDocument, createPlatformFactory, platformCore, Renderer2, ApplicationRef, ɵisPromise, importProvidersFrom, ɵinternalCreateApplication, Version } from '@angular/core';\nimport * as i1 from '@angular/platform-browser';\nimport { ɵBrowserDomAdapter, ɵflattenStyles, ɵNAMESPACE_URIS, ɵshimContentAttribute, ɵshimHostAttribute, ɵSharedStylesHost, ɵTRANSITION_ID, TransferState, ɵescapeHtml, EVENT_MANAGER_PLUGINS, BrowserModule } from '@angular/platform-browser';\nimport domino from 'domino';\nimport { ɵAnimationEngine } from '@angular/animations/browser';\nimport { ɵHttpInterceptorHandler, HttpBackend, HttpHandler, HttpClientModule } from '@angular/common/http';\nimport { ɵplatformCoreDynamic } from '@angular/platform-browser-dynamic';\nimport { ɵAnimationRendererFactory, NoopAnimationsModule } from '@angular/platform-browser/animations';\nimport { Observable, Subject } from 'rxjs';\nimport * as xhr2 from 'xhr2';\nimport * as url from 'url';\nimport { DomElementSchemaRegistry } from '@angular/compiler';\nimport { first } from 'rxjs/operators';\nfunction setDomTypes() {\n  // Make all Domino types available in the global env.\n  Object.assign(global, domino.impl);\n  global['KeyboardEvent'] = domino.impl.Event;\n}\n/**\n * Parses a document string to a Document object.\n */\nfunction parseDocument(html, url = '/') {\n  let window = domino.createWindow(html, url);\n  let doc = window.document;\n  return doc;\n}\n/**\n * Serializes a document to string.\n */\nfunction serializeDocument(doc) {\n  return doc.serialize();\n}\n/**\n * DOM Adapter for the server platform based on https://github.com/fgnass/domino.\n */\nclass DominoAdapter extends ɵBrowserDomAdapter {\n  constructor() {\n    super(...arguments);\n    this.supportsDOMEvents = false;\n  }\n  static makeCurrent() {\n    setDomTypes();\n    ɵsetRootDomAdapter(new DominoAdapter());\n  }\n  createHtmlDocument() {\n    return parseDocument('<html><head><title>fakeTitle</title></head><body></body></html>');\n  }\n  getDefaultDocument() {\n    if (!DominoAdapter.defaultDoc) {\n      DominoAdapter.defaultDoc = domino.createDocument();\n    }\n    return DominoAdapter.defaultDoc;\n  }\n  isElementNode(node) {\n    return node ? node.nodeType === DominoAdapter.defaultDoc.ELEMENT_NODE : false;\n  }\n  isShadowRoot(node) {\n    return node.shadowRoot == node;\n  }\n  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n  getGlobalEventTarget(doc, target) {\n    if (target === 'window') {\n      return doc.defaultView;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  getBaseHref(doc) {\n    // TODO(alxhub): Need relative path logic from BrowserDomAdapter here?\n    return doc.documentElement.querySelector('base')?.getAttribute('href') || '';\n  }\n  dispatchEvent(el, evt) {\n    el.dispatchEvent(evt);\n    // Dispatch the event to the window also.\n    const doc = el.ownerDocument || el;\n    const win = doc.defaultView;\n    if (win) {\n      win.dispatchEvent(evt);\n    }\n  }\n  getUserAgent() {\n    return 'Fake user agent';\n  }\n  getCookie(name) {\n    throw new Error('getCookie has not been implemented');\n  }\n}\n\n/**\n * Representation of the current platform state.\n *\n * @publicApi\n */\nlet PlatformState = /*#__PURE__*/(() => {\n  class PlatformState {\n    constructor(_doc) {\n      this._doc = _doc;\n    }\n    /**\n     * Renders the current state of the platform to string.\n     */\n    renderToString() {\n      return serializeDocument(this._doc);\n    }\n    /**\n     * Returns the current DOM state.\n     */\n    getDocument() {\n      return this._doc;\n    }\n  }\n  PlatformState.ɵfac = function PlatformState_Factory(t) {\n    return new (t || PlatformState)(i0.ɵɵinject(DOCUMENT));\n  };\n  PlatformState.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PlatformState,\n    factory: PlatformState.ɵfac\n  });\n  return PlatformState;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The DI token for setting the initial config for the platform.\n *\n * @publicApi\n */\nconst INITIAL_CONFIG = /*#__PURE__*/new InjectionToken('Server.INITIAL_CONFIG');\n/**\n * A function that will be executed when calling `renderApplication`, `renderModuleFactory` or\n * `renderModule` just before current platform state is rendered to string.\n *\n * @publicApi\n */\nconst BEFORE_APP_SERIALIZED = /*#__PURE__*/new InjectionToken('Server.RENDER_MODULE_HOOK');\n\n// @see https://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#URI-syntax\nconst isAbsoluteUrl = /^[a-zA-Z\\-\\+.]+:\\/\\//;\nlet ServerXhr = /*#__PURE__*/(() => {\n  class ServerXhr {\n    build() {\n      return new xhr2.XMLHttpRequest();\n    }\n  }\n  ServerXhr.ɵfac = function ServerXhr_Factory(t) {\n    return new (t || ServerXhr)();\n  };\n  ServerXhr.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ServerXhr,\n    factory: ServerXhr.ɵfac\n  });\n  return ServerXhr;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass ZoneMacroTaskWrapper {\n  wrap(request) {\n    return new Observable(observer => {\n      let task = null;\n      let scheduled = false;\n      let sub = null;\n      let savedResult = null;\n      let savedError = null;\n      const scheduleTask = _task => {\n        task = _task;\n        scheduled = true;\n        const delegate = this.delegate(request);\n        sub = delegate.subscribe(res => savedResult = res, err => {\n          if (!scheduled) {\n            throw new Error('An http observable was completed twice. This shouldn\\'t happen, please file a bug.');\n          }\n          savedError = err;\n          scheduled = false;\n          task.invoke();\n        }, () => {\n          if (!scheduled) {\n            throw new Error('An http observable was completed twice. This shouldn\\'t happen, please file a bug.');\n          }\n          scheduled = false;\n          task.invoke();\n        });\n      };\n      const cancelTask = _task => {\n        if (!scheduled) {\n          return;\n        }\n        scheduled = false;\n        if (sub) {\n          sub.unsubscribe();\n          sub = null;\n        }\n      };\n      const onComplete = () => {\n        if (savedError !== null) {\n          observer.error(savedError);\n        } else {\n          observer.next(savedResult);\n          observer.complete();\n        }\n      };\n      // MockBackend for Http is synchronous, which means that if scheduleTask is by\n      // scheduleMacroTask, the request will hit MockBackend and the response will be\n      // sent, causing task.invoke() to be called.\n      const _task = Zone.current.scheduleMacroTask('ZoneMacroTaskWrapper.subscribe', onComplete, {}, () => null, cancelTask);\n      scheduleTask(_task);\n      return () => {\n        if (scheduled && task) {\n          task.zone.cancelTask(task);\n          scheduled = false;\n        }\n        if (sub) {\n          sub.unsubscribe();\n          sub = null;\n        }\n      };\n    });\n  }\n}\nclass ZoneClientBackend extends ZoneMacroTaskWrapper {\n  constructor(backend, platformLocation, config) {\n    super();\n    this.backend = backend;\n    this.platformLocation = platformLocation;\n    this.config = config;\n  }\n  handle(request) {\n    const {\n      href,\n      protocol,\n      hostname,\n      port\n    } = this.platformLocation;\n    if (this.config.useAbsoluteUrl && !isAbsoluteUrl.test(request.url) && isAbsoluteUrl.test(href)) {\n      const baseHref = this.platformLocation.getBaseHrefFromDOM() || href;\n      const urlPrefix = `${protocol}//${hostname}` + (port ? `:${port}` : '');\n      const baseUrl = new URL(baseHref, urlPrefix);\n      const url = new URL(request.url, baseUrl);\n      return this.wrap(request.clone({\n        url: url.toString()\n      }));\n    }\n    return this.wrap(request);\n  }\n  delegate(request) {\n    return this.backend.handle(request);\n  }\n}\nfunction zoneWrappedInterceptorHandler(platformLocation, config) {\n  return new ZoneClientBackend(new ɵHttpInterceptorHandler(inject(HttpBackend), inject(EnvironmentInjector)), platformLocation, config);\n}\nconst SERVER_HTTP_PROVIDERS = [{\n  provide: XhrFactory,\n  useClass: ServerXhr\n}, {\n  provide: HttpHandler,\n  useFactory: zoneWrappedInterceptorHandler,\n  deps: [PlatformLocation, INITIAL_CONFIG]\n}];\nfunction parseUrl(urlStr) {\n  const parsedUrl = url.parse(urlStr);\n  return {\n    hostname: parsedUrl.hostname || '',\n    protocol: parsedUrl.protocol || '',\n    port: parsedUrl.port || '',\n    pathname: parsedUrl.pathname || '',\n    search: parsedUrl.search || '',\n    hash: parsedUrl.hash || ''\n  };\n}\n/**\n * Server-side implementation of URL state. Implements `pathname`, `search`, and `hash`\n * but not the state stack.\n */\nlet ServerPlatformLocation = /*#__PURE__*/(() => {\n  class ServerPlatformLocation {\n    constructor(_doc, _config) {\n      this._doc = _doc;\n      this.href = '/';\n      this.hostname = '/';\n      this.protocol = '/';\n      this.port = '/';\n      this.pathname = '/';\n      this.search = '';\n      this.hash = '';\n      this._hashUpdate = new Subject();\n      const config = _config;\n      if (!config) {\n        return;\n      }\n      if (config.url) {\n        const url = parseUrl(config.url);\n        this.protocol = url.protocol;\n        this.hostname = url.hostname;\n        this.port = url.port;\n        this.pathname = url.pathname;\n        this.search = url.search;\n        this.hash = url.hash;\n        this.href = _doc.location.href;\n      }\n      if (config.useAbsoluteUrl) {\n        if (!config.baseUrl) {\n          throw new Error(`\"PlatformConfig.baseUrl\" must be set if \"useAbsoluteUrl\" is true`);\n        }\n        const url = parseUrl(config.baseUrl);\n        this.protocol = url.protocol;\n        this.hostname = url.hostname;\n        this.port = url.port;\n      }\n    }\n    getBaseHrefFromDOM() {\n      return ɵgetDOM().getBaseHref(this._doc);\n    }\n    onPopState(fn) {\n      // No-op: a state stack is not implemented, so\n      // no events will ever come.\n      return () => {};\n    }\n    onHashChange(fn) {\n      const subscription = this._hashUpdate.subscribe(fn);\n      return () => subscription.unsubscribe();\n    }\n    get url() {\n      return `${this.pathname}${this.search}${this.hash}`;\n    }\n    setHash(value, oldUrl) {\n      if (this.hash === value) {\n        // Don't fire events if the hash has not changed.\n        return;\n      }\n      this.hash = value;\n      const newUrl = this.url;\n      scheduleMicroTask(() => this._hashUpdate.next({\n        type: 'hashchange',\n        state: null,\n        oldUrl,\n        newUrl\n      }));\n    }\n    replaceState(state, title, newUrl) {\n      const oldUrl = this.url;\n      const parsedUrl = parseUrl(newUrl);\n      this.pathname = parsedUrl.pathname;\n      this.search = parsedUrl.search;\n      this.setHash(parsedUrl.hash, oldUrl);\n    }\n    pushState(state, title, newUrl) {\n      this.replaceState(state, title, newUrl);\n    }\n    forward() {\n      throw new Error('Not implemented');\n    }\n    back() {\n      throw new Error('Not implemented');\n    }\n    // History API isn't available on server, therefore return undefined\n    getState() {\n      return undefined;\n    }\n  }\n  ServerPlatformLocation.ɵfac = function ServerPlatformLocation_Factory(t) {\n    return new (t || ServerPlatformLocation)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(INITIAL_CONFIG, 8));\n  };\n  ServerPlatformLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ServerPlatformLocation,\n    factory: ServerPlatformLocation.ɵfac\n  });\n  return ServerPlatformLocation;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction scheduleMicroTask(fn) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\nlet ServerEventManagerPlugin /* extends EventManagerPlugin which is private */ = /*#__PURE__*/(() => {\n  class ServerEventManagerPlugin /* extends EventManagerPlugin which is private */ {\n    constructor(doc) {\n      this.doc = doc;\n    }\n    // Handle all events on the server.\n    supports(eventName) {\n      return true;\n    }\n    addEventListener(element, eventName, handler) {\n      return ɵgetDOM().onAndCancel(element, eventName, handler);\n    }\n    /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n    addGlobalEventListener(element, eventName, handler) {\n      const target = ɵgetDOM().getGlobalEventTarget(this.doc, element);\n      if (!target) {\n        throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n      }\n      return this.addEventListener(target, eventName, handler);\n    }\n  }\n  ServerEventManagerPlugin.ɵfac = function ServerEventManagerPlugin_Factory(t) {\n    return new (t || ServerEventManagerPlugin)(i0.ɵɵinject(DOCUMENT));\n  };\n  ServerEventManagerPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ServerEventManagerPlugin,\n    factory: ServerEventManagerPlugin.ɵfac\n  });\n  return ServerEventManagerPlugin /* extends EventManagerPlugin which is private */;\n})();\n\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EMPTY_ARRAY = [];\nconst DEFAULT_SCHEMA = /*#__PURE__*/new DomElementSchemaRegistry();\nlet ServerRendererFactory2 = /*#__PURE__*/(() => {\n  class ServerRendererFactory2 {\n    constructor(eventManager, ngZone, document, sharedStylesHost) {\n      this.eventManager = eventManager;\n      this.ngZone = ngZone;\n      this.document = document;\n      this.sharedStylesHost = sharedStylesHost;\n      this.rendererByCompId = new Map();\n      this.schema = DEFAULT_SCHEMA;\n      this.defaultRenderer = new DefaultServerRenderer2(eventManager, document, ngZone, this.schema);\n    }\n    createRenderer(element, type) {\n      if (!element || !type) {\n        return this.defaultRenderer;\n      }\n      switch (type.encapsulation) {\n        case ViewEncapsulation.Emulated:\n          {\n            let renderer = this.rendererByCompId.get(type.id);\n            if (!renderer) {\n              renderer = new EmulatedEncapsulationServerRenderer2(this.eventManager, this.document, this.ngZone, this.sharedStylesHost, this.schema, type);\n              this.rendererByCompId.set(type.id, renderer);\n            }\n            renderer.applyToHost(element);\n            return renderer;\n          }\n        default:\n          {\n            if (!this.rendererByCompId.has(type.id)) {\n              const styles = ɵflattenStyles(type.id, type.styles);\n              this.sharedStylesHost.addStyles(styles);\n              this.rendererByCompId.set(type.id, this.defaultRenderer);\n            }\n            return this.defaultRenderer;\n          }\n      }\n    }\n    begin() {}\n    end() {}\n  }\n  ServerRendererFactory2.ɵfac = function ServerRendererFactory2_Factory(t) {\n    return new (t || ServerRendererFactory2)(i0.ɵɵinject(i1.EventManager), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1.ɵSharedStylesHost));\n  };\n  ServerRendererFactory2.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ServerRendererFactory2,\n    factory: ServerRendererFactory2.ɵfac\n  });\n  return ServerRendererFactory2;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DefaultServerRenderer2 {\n  constructor(eventManager, document, ngZone, schema) {\n    this.eventManager = eventManager;\n    this.document = document;\n    this.ngZone = ngZone;\n    this.schema = schema;\n    this.data = Object.create(null);\n    this.destroyNode = null;\n  }\n  destroy() {}\n  createElement(name, namespace) {\n    if (namespace) {\n      const doc = this.document || ɵgetDOM().getDefaultDocument();\n      return doc.createElementNS(ɵNAMESPACE_URIS[namespace], name);\n    }\n    return ɵgetDOM().createElement(name, this.document);\n  }\n  createComment(value) {\n    return ɵgetDOM().getDefaultDocument().createComment(value);\n  }\n  createText(value) {\n    const doc = ɵgetDOM().getDefaultDocument();\n    return doc.createTextNode(value);\n  }\n  appendChild(parent, newChild) {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.appendChild(newChild);\n  }\n  insertBefore(parent, newChild, refChild) {\n    if (parent) {\n      const targetParent = isTemplateNode(parent) ? parent.content : parent;\n      targetParent.insertBefore(newChild, refChild);\n    }\n  }\n  removeChild(parent, oldChild) {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n  selectRootElement(selectorOrNode, preserveContent) {\n    const el = typeof selectorOrNode === 'string' ? this.document.querySelector(selectorOrNode) : selectorOrNode;\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    if (!preserveContent) {\n      while (el.firstChild) {\n        el.removeChild(el.firstChild);\n      }\n    }\n    return el;\n  }\n  parentNode(node) {\n    return node.parentNode;\n  }\n  nextSibling(node) {\n    return node.nextSibling;\n  }\n  setAttribute(el, name, value, namespace) {\n    if (namespace) {\n      el.setAttributeNS(ɵNAMESPACE_URIS[namespace], namespace + ':' + name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n  removeAttribute(el, name, namespace) {\n    if (namespace) {\n      el.removeAttributeNS(ɵNAMESPACE_URIS[namespace], name);\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n  addClass(el, name) {\n    el.classList.add(name);\n  }\n  removeClass(el, name) {\n    el.classList.remove(name);\n  }\n  setStyle(el, style, value, flags) {\n    style = style.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n    value = value == null ? '' : `${value}`.trim();\n    const styleMap = _readStyleAttribute(el);\n    if (flags & RendererStyleFlags2.Important) {\n      value += ' !important';\n    }\n    styleMap[style] = value;\n    _writeStyleAttribute(el, styleMap);\n  }\n  removeStyle(el, style, flags) {\n    // IE requires '' instead of null\n    // see https://github.com/angular/angular/issues/7916\n    this.setStyle(el, style, '', flags);\n  }\n  // The value was validated already as a property binding, against the property name.\n  // To know this value is safe to use as an attribute, the security context of the\n  // attribute with the given name is checked against that security context of the\n  // property.\n  _isSafeToReflectProperty(tagName, propertyName) {\n    return this.schema.securityContext(tagName, propertyName, true) === this.schema.securityContext(tagName, propertyName, false);\n  }\n  setProperty(el, name, value) {\n    checkNoSyntheticProp(name, 'property');\n    if (name === 'innerText') {\n      // Domino does not support innerText. Just map it to textContent.\n      el.textContent = value;\n    }\n    el[name] = value;\n    // Mirror property values for known HTML element properties in the attributes.\n    // Skip `innerhtml` which is conservatively marked as an attribute for security\n    // purposes but is not actually an attribute.\n    const tagName = el.tagName.toLowerCase();\n    if (value != null && (typeof value === 'number' || typeof value == 'string') && name.toLowerCase() !== 'innerhtml' && this.schema.hasElement(tagName, EMPTY_ARRAY) && this.schema.hasProperty(tagName, name, EMPTY_ARRAY) && this._isSafeToReflectProperty(tagName, name)) {\n      this.setAttribute(el, name, value.toString());\n    }\n  }\n  setValue(node, value) {\n    node.textContent = value;\n  }\n  listen(target, eventName, callback) {\n    checkNoSyntheticProp(eventName, 'listener');\n    if (typeof target === 'string') {\n      return this.eventManager.addGlobalEventListener(target, eventName, this.decoratePreventDefault(callback));\n    }\n    return this.eventManager.addEventListener(target, eventName, this.decoratePreventDefault(callback));\n  }\n  decoratePreventDefault(eventHandler) {\n    return event => {\n      // Ivy uses `Function` as a special token that allows us to unwrap the function\n      // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n      if (event === Function) {\n        return eventHandler;\n      }\n      // Run the event handler inside the ngZone because event handlers are not patched\n      // by Zone on the server. This is required only for tests.\n      const allowDefaultBehavior = this.ngZone.runGuarded(() => eventHandler(event));\n      if (allowDefaultBehavior === false) {\n        event.preventDefault();\n        event.returnValue = false;\n      }\n      return undefined;\n    };\n  }\n}\nconst AT_CHARCODE = /*#__PURE__*/'@'.charCodeAt(0);\nfunction checkNoSyntheticProp(name, nameKind) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Either \\`BrowserAnimationsModule\\` or \\`NoopAnimationsModule\\` are imported in your application.\n  - There is corresponding configuration for the animation named \\`${name}\\` defined in the \\`animations\\` field of the \\`@Component\\` decorator (see https://angular.io/api/core/Component#animations).`);\n  }\n}\nfunction isTemplateNode(node) {\n  return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\nclass EmulatedEncapsulationServerRenderer2 extends DefaultServerRenderer2 {\n  constructor(eventManager, document, ngZone, sharedStylesHost, schema, component) {\n    super(eventManager, document, ngZone, schema);\n    this.component = component;\n    // Add a 's' prefix to style attributes to indicate server.\n    const componentId = 's' + component.id;\n    const styles = ɵflattenStyles(componentId, component.styles);\n    sharedStylesHost.addStyles(styles);\n    this.contentAttr = ɵshimContentAttribute(componentId);\n    this.hostAttr = ɵshimHostAttribute(componentId);\n  }\n  applyToHost(element) {\n    super.setAttribute(element, this.hostAttr, '');\n  }\n  createElement(parent, name) {\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n}\nfunction _readStyleAttribute(element) {\n  const styleMap = {};\n  const styleAttribute = element.getAttribute('style');\n  if (styleAttribute) {\n    const styleList = styleAttribute.split(/;+/g);\n    for (let i = 0; i < styleList.length; i++) {\n      const style = styleList[i].trim();\n      if (style.length > 0) {\n        const colonIndex = style.indexOf(':');\n        if (colonIndex === -1) {\n          throw new Error(`Invalid CSS style: ${style}`);\n        }\n        const name = style.slice(0, colonIndex).trim();\n        styleMap[name] = style.slice(colonIndex + 1).trim();\n      }\n    }\n  }\n  return styleMap;\n}\nfunction _writeStyleAttribute(element, styleMap) {\n  // We have to construct the `style` attribute ourselves, instead of going through\n  // `element.style.setProperty` like the other renderers, because `setProperty` won't\n  // write newer CSS properties that Domino doesn't know about like `clip-path`.\n  let styleAttrValue = '';\n  for (const key in styleMap) {\n    const newValue = styleMap[key];\n    if (newValue != null && newValue !== '') {\n      styleAttrValue += key + ':' + newValue + ';';\n    }\n  }\n  if (styleAttrValue) {\n    element.setAttribute('style', styleAttrValue);\n  } else {\n    element.removeAttribute('style');\n  }\n}\nlet ServerStylesHost = /*#__PURE__*/(() => {\n  class ServerStylesHost extends ɵSharedStylesHost {\n    constructor(doc, transitionId) {\n      super();\n      this.doc = doc;\n      this.transitionId = transitionId;\n      this.head = null;\n      this._styleNodes = new Set();\n      this.head = doc.getElementsByTagName('head')[0];\n    }\n    onStyleAdded(style) {\n      const adapter = ɵgetDOM();\n      const el = adapter.createElement('style');\n      el.textContent = style;\n      if (!!this.transitionId) {\n        el.setAttribute('ng-transition', this.transitionId);\n      }\n      this.head.appendChild(el);\n      this._styleNodes.add(el);\n    }\n    ngOnDestroy() {\n      this._styleNodes.forEach(styleNode => styleNode.remove());\n      this._styleNodes.clear();\n      super.ngOnDestroy();\n    }\n  }\n  ServerStylesHost.ɵfac = function ServerStylesHost_Factory(t) {\n    return new (t || ServerStylesHost)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(ɵTRANSITION_ID, 8));\n  };\n  ServerStylesHost.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ServerStylesHost,\n    factory: ServerStylesHost.ɵfac\n  });\n  return ServerStylesHost;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TRANSFER_STATE_SERIALIZATION_PROVIDERS = [{\n  provide: BEFORE_APP_SERIALIZED,\n  useFactory: serializeTransferStateFactory,\n  deps: [DOCUMENT, APP_ID, TransferState],\n  multi: true\n}];\nfunction serializeTransferStateFactory(doc, appId, transferStore) {\n  return () => {\n    // The `.toJSON` here causes the `onSerialize` callbacks to be called.\n    // These callbacks can be used to provide the value for a given key.\n    const content = transferStore.toJson();\n    if (transferStore.isEmpty) {\n      // The state is empty, nothing to transfer,\n      // avoid creating an extra `<script>` tag in this case.\n      return;\n    }\n    const script = doc.createElement('script');\n    script.id = appId + '-state';\n    script.setAttribute('type', 'application/json');\n    script.textContent = ɵescapeHtml(content);\n    // It is intentional that we add the script at the very bottom. Angular CLI script tags for\n    // bundles are always `type=\"module\"`. These are deferred by default and cause the transfer\n    // transfer data to be queried only after the browser has finished parsing the DOM.\n    doc.body.appendChild(script);\n  };\n}\n/**\n * NgModule to install on the server side while using the `TransferState` to transfer state from\n * server to client.\n *\n * Note: this module is not needed if the `renderApplication` function is used.\n * The `renderApplication` makes all providers from this module available in the application.\n *\n * @publicApi\n * @deprecated no longer needed, you can inject the `TransferState` in an app without providing\n *     this module.\n */\nlet ServerTransferStateModule = /*#__PURE__*/(() => {\n  class ServerTransferStateModule {}\n  ServerTransferStateModule.ɵfac = function ServerTransferStateModule_Factory(t) {\n    return new (t || ServerTransferStateModule)();\n  };\n  ServerTransferStateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ServerTransferStateModule\n  });\n  ServerTransferStateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ServerTransferStateModule;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst INTERNAL_SERVER_PLATFORM_PROVIDERS = [{\n  provide: DOCUMENT,\n  useFactory: _document,\n  deps: [Injector]\n}, {\n  provide: PLATFORM_ID,\n  useValue: ɵPLATFORM_SERVER_ID\n}, {\n  provide: PLATFORM_INITIALIZER,\n  useFactory: initDominoAdapter,\n  multi: true\n}, {\n  provide: PlatformLocation,\n  useClass: ServerPlatformLocation,\n  deps: [DOCUMENT, [Optional, INITIAL_CONFIG]]\n}, {\n  provide: PlatformState,\n  deps: [DOCUMENT]\n},\n// Add special provider that allows multiple instances of platformServer* to be created.\n{\n  provide: ɵALLOW_MULTIPLE_PLATFORMS,\n  useValue: true\n}];\nfunction initDominoAdapter() {\n  return () => {\n    DominoAdapter.makeCurrent();\n  };\n}\nfunction instantiateServerRendererFactory(renderer, engine, zone) {\n  return new ɵAnimationRendererFactory(renderer, engine, zone);\n}\nconst SERVER_RENDER_PROVIDERS = [ServerRendererFactory2, {\n  provide: RendererFactory2,\n  useFactory: instantiateServerRendererFactory,\n  deps: [ServerRendererFactory2, ɵAnimationEngine, NgZone]\n}, ServerStylesHost, {\n  provide: ɵSharedStylesHost,\n  useExisting: ServerStylesHost\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  multi: true,\n  useClass: ServerEventManagerPlugin\n}];\n/**\n * The ng module for the server.\n *\n * @publicApi\n */\nlet ServerModule = /*#__PURE__*/(() => {\n  class ServerModule {}\n  ServerModule.ɵfac = function ServerModule_Factory(t) {\n    return new (t || ServerModule)();\n  };\n  ServerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ServerModule\n  });\n  ServerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [TRANSFER_STATE_SERIALIZATION_PROVIDERS, SERVER_RENDER_PROVIDERS, SERVER_HTTP_PROVIDERS, {\n      provide: Testability,\n      useValue: null\n    }, {\n      provide: ɵTESTABILITY,\n      useValue: null\n    }, {\n      provide: ViewportScroller,\n      useClass: ɵNullViewportScroller\n    }],\n    imports: [HttpClientModule, NoopAnimationsModule, BrowserModule]\n  });\n  return ServerModule;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction _document(injector) {\n  const config = injector.get(INITIAL_CONFIG, null);\n  let document;\n  if (config && config.document) {\n    document = typeof config.document === 'string' ? parseDocument(config.document, config.url) : config.document;\n  } else {\n    document = ɵgetDOM().createHtmlDocument();\n  }\n  // Tell ivy about the global document\n  ɵsetDocument(document);\n  return document;\n}\n/**\n * @publicApi\n */\nconst platformServer = /*#__PURE__*/createPlatformFactory(platformCore, 'server', INTERNAL_SERVER_PLATFORM_PROVIDERS);\n/**\n * The server platform that supports the runtime compiler.\n *\n * @publicApi\n */\nconst platformDynamicServer = /*#__PURE__*/createPlatformFactory(ɵplatformCoreDynamic, 'serverDynamic', INTERNAL_SERVER_PLATFORM_PROVIDERS);\nfunction _getPlatform(platformFactory, options) {\n  const extraProviders = options.platformProviders ?? [];\n  return platformFactory([{\n    provide: INITIAL_CONFIG,\n    useValue: {\n      document: options.document,\n      url: options.url\n    }\n  }, extraProviders]);\n}\n/**\n * Adds the `ng-server-context` attribute to host elements of all bootstrapped components\n * within a given application.\n */\nfunction appendServerContextInfo(serverContext, applicationRef) {\n  applicationRef.components.forEach(componentRef => {\n    const renderer = componentRef.injector.get(Renderer2);\n    const element = componentRef.location.nativeElement;\n    if (element) {\n      renderer.setAttribute(element, 'ng-server-context', serverContext);\n    }\n  });\n}\nfunction _render(platform, bootstrapPromise) {\n  return bootstrapPromise.then(moduleOrApplicationRef => {\n    const environmentInjector = moduleOrApplicationRef.injector;\n    const transitionId = environmentInjector.get(ɵTRANSITION_ID, null);\n    if (!transitionId) {\n      throw new Error(`renderModule[Factory]() requires the use of BrowserModule.withServerTransition() to ensure\nthe server-rendered app can be properly bootstrapped into a client app.`);\n    }\n    const applicationRef = moduleOrApplicationRef instanceof ApplicationRef ? moduleOrApplicationRef : environmentInjector.get(ApplicationRef);\n    const serverContext = sanitizeServerContext(environmentInjector.get(SERVER_CONTEXT, DEFAULT_SERVER_CONTEXT));\n    return applicationRef.isStable.pipe(first(isStable => isStable)).toPromise().then(() => {\n      appendServerContextInfo(serverContext, applicationRef);\n      const platformState = platform.injector.get(PlatformState);\n      const asyncPromises = [];\n      // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.\n      const callbacks = environmentInjector.get(BEFORE_APP_SERIALIZED, null);\n      if (callbacks) {\n        for (const callback of callbacks) {\n          try {\n            const callbackResult = callback();\n            if (ɵisPromise(callbackResult)) {\n              // TODO: in TS3.7, callbackResult is void.\n              asyncPromises.push(callbackResult);\n            }\n          } catch (e) {\n            // Ignore exceptions.\n            console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);\n          }\n        }\n      }\n      const complete = () => {\n        const output = platformState.renderToString();\n        platform.destroy();\n        return output;\n      };\n      if (asyncPromises.length === 0) {\n        return complete();\n      }\n      return Promise.all(asyncPromises.map(asyncPromise => {\n        return asyncPromise.catch(e => {\n          console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);\n        });\n      })).then(complete);\n    });\n  });\n}\n/**\n * Specifies the value that should be used if no server context value has been provided.\n */\nconst DEFAULT_SERVER_CONTEXT = 'other';\n/**\n * An internal token that allows providing extra information about the server context\n * (e.g. whether SSR or SSG was used). The value is a string and characters other\n * than [a-zA-Z0-9\\-] are removed. See the default value in `DEFAULT_SERVER_CONTEXT` const.\n */\nconst SERVER_CONTEXT = /*#__PURE__*/new InjectionToken('SERVER_CONTEXT');\n/**\n * Sanitizes provided server context:\n * - removes all characters other than a-z, A-Z, 0-9 and `-`\n * - returns `other` if nothing is provided or the string is empty after sanitization\n */\nfunction sanitizeServerContext(serverContext) {\n  const context = serverContext.replace(/[^a-zA-Z0-9\\-]/g, '');\n  return context.length > 0 ? context : DEFAULT_SERVER_CONTEXT;\n}\n/**\n * Bootstraps an application using provided NgModule and serializes the page content to string.\n *\n * @param moduleType A reference to an NgModule that should be used for bootstrap.\n * @param options Additional configuration for the render operation:\n *  - `document` - the document of the page to render, either as an HTML string or\n *                 as a reference to the `document` instance.\n *  - `url` - the URL for the current render request.\n *  - `extraProviders` - set of platform level providers for the current render request.\n *\n * @publicApi\n */\nfunction renderModule(moduleType, options) {\n  const {\n    document,\n    url,\n    extraProviders: platformProviders\n  } = options;\n  const platform = _getPlatform(platformDynamicServer, {\n    document,\n    url,\n    platformProviders\n  });\n  return _render(platform, platform.bootstrapModule(moduleType));\n}\n/**\n * Bootstraps an instance of an Angular application and renders it to a string.\n *\n * Note: the root component passed into this function *must* be a standalone one (should have the\n * `standalone: true` flag in the `@Component` decorator config).\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   template: 'Hello world!'\n * })\n * class RootComponent {}\n *\n * const output: string = await renderApplication(RootComponent, {appId: 'server-app'});\n * ```\n *\n * @param rootComponent A reference to a Standalone Component that should be rendered.\n * @param options Additional configuration for the render operation:\n *  - `appId` - a string identifier of this application. The appId is used to prefix all\n *              server-generated stylings and state keys of the application in TransferState\n *              use-cases.\n *  - `document` - the document of the page to render, either as an HTML string or\n *                 as a reference to the `document` instance.\n *  - `url` - the URL for the current render request.\n *  - `providers` - set of application level providers for the current render request.\n *  - `platformProviders` - the platform level providers for the current render request.\n *\n * @returns A Promise, that returns serialized (to a string) rendered page, once resolved.\n *\n * @publicApi\n * @developerPreview\n */\nfunction renderApplication(rootComponent, options) {\n  const {\n    document,\n    url,\n    platformProviders,\n    appId\n  } = options;\n  const platform = _getPlatform(platformDynamicServer, {\n    document,\n    url,\n    platformProviders\n  });\n  const appProviders = [importProvidersFrom(BrowserModule.withServerTransition({\n    appId\n  })), importProvidersFrom(ServerModule), ...(options.providers ?? [])];\n  return _render(platform, ɵinternalCreateApplication({\n    rootComponent,\n    appProviders\n  }));\n}\n/**\n * Bootstraps an application using provided {@link NgModuleFactory} and serializes the page content\n * to string.\n *\n * @param moduleFactory An instance of the {@link NgModuleFactory} that should be used for\n *     bootstrap.\n * @param options Additional configuration for the render operation:\n *  - `document` - the document of the page to render, either as an HTML string or\n *                 as a reference to the `document` instance.\n *  - `url` - the URL for the current render request.\n *  - `extraProviders` - set of platform level providers for the current render request.\n *\n * @publicApi\n *\n * @deprecated\n * This symbol is no longer necessary as of Angular v13.\n * Use {@link renderModule} API instead.\n */\nfunction renderModuleFactory(moduleFactory, options) {\n  const {\n    document,\n    url,\n    extraProviders: platformProviders\n  } = options;\n  const platform = _getPlatform(platformServer, {\n    document,\n    url,\n    platformProviders\n  });\n  return _render(platform, platform.bootstrapModuleFactory(moduleFactory));\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-server package.\n */\n/**\n * @publicApi\n */\nconst VERSION = /*#__PURE__*/new Version('15.2.7');\n\n/// <reference types=\"node\" />\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BEFORE_APP_SERIALIZED, INITIAL_CONFIG, PlatformState, ServerModule, ServerTransferStateModule, VERSION, platformDynamicServer, platformServer, renderApplication, renderModule, renderModuleFactory, INTERNAL_SERVER_PLATFORM_PROVIDERS as ɵINTERNAL_SERVER_PLATFORM_PROVIDERS, SERVER_CONTEXT as ɵSERVER_CONTEXT, SERVER_RENDER_PROVIDERS as ɵSERVER_RENDER_PROVIDERS, ServerRendererFactory2 as ɵServerRendererFactory2, setDomTypes as ɵsetDomTypes };\n//# sourceMappingURL=platform-server.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}