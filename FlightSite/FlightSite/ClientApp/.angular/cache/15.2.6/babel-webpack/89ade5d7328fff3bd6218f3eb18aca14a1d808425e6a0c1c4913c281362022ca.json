{"ast":null,"code":"\"use strict\";\n\nvar utils = require('./utils');\nexports.property = function (attr) {\n  if (Array.isArray(attr.type)) {\n    var valid = Object.create(null);\n    attr.type.forEach(function (val) {\n      valid[val.value || val] = val.alias || val;\n    });\n    var missingValueDefault = attr.missing;\n    if (missingValueDefault === undefined) {\n      missingValueDefault = null;\n    }\n    var invalidValueDefault = attr.invalid;\n    if (invalidValueDefault === undefined) {\n      invalidValueDefault = missingValueDefault;\n    }\n    return {\n      get: function () {\n        var v = this._getattr(attr.name);\n        if (v === null) return missingValueDefault;\n        v = valid[v.toLowerCase()];\n        if (v !== undefined) return v;\n        if (invalidValueDefault !== null) return invalidValueDefault;\n        return v;\n      },\n      set: function (v) {\n        this._setattr(attr.name, v);\n      }\n    };\n  } else if (attr.type === Boolean) {\n    return {\n      get: function () {\n        return this.hasAttribute(attr.name);\n      },\n      set: function (v) {\n        if (v) {\n          this._setattr(attr.name, '');\n        } else {\n          this.removeAttribute(attr.name);\n        }\n      }\n    };\n  } else if (attr.type === Number || attr.type === \"long\" || attr.type === \"unsigned long\" || attr.type === \"limited unsigned long with fallback\") {\n    return numberPropDesc(attr);\n  } else if (!attr.type || attr.type === String) {\n    return {\n      get: function () {\n        return this._getattr(attr.name) || '';\n      },\n      set: function (v) {\n        if (attr.treatNullAsEmptyString && v === null) {\n          v = '';\n        }\n        this._setattr(attr.name, v);\n      }\n    };\n  } else if (typeof attr.type === 'function') {\n    return attr.type(attr.name, attr);\n  }\n  throw new Error('Invalid attribute definition');\n};\n\n// See http://www.whatwg.org/specs/web-apps/current-work/#reflect\n//\n// defval is the default value. If it is a function, then that function\n// will be invoked as a method of the element to obtain the default.\n// If no default is specified for a given attribute, then the default\n// depends on the type of the attribute, but since this function handles\n// 4 integer cases, you must specify the default value in each call\n//\n// min and max define a valid range for getting the attribute.\n//\n// setmin defines a minimum value when setting.  If the value is less\n// than that, then throw INDEX_SIZE_ERR.\n//\n// Conveniently, JavaScript's parseInt function appears to be\n// compatible with HTML's 'rules for parsing integers'\nfunction numberPropDesc(a) {\n  var def;\n  if (typeof a.default === 'function') {\n    def = a.default;\n  } else if (typeof a.default === 'number') {\n    def = function () {\n      return a.default;\n    };\n  } else {\n    def = function () {\n      utils.assert(false, typeof a.default);\n    };\n  }\n  var unsigned_long = a.type === 'unsigned long';\n  var signed_long = a.type === 'long';\n  var unsigned_fallback = a.type === 'limited unsigned long with fallback';\n  var min = a.min,\n    max = a.max,\n    setmin = a.setmin;\n  if (min === undefined) {\n    if (unsigned_long) min = 0;\n    if (signed_long) min = -0x80000000;\n    if (unsigned_fallback) min = 1;\n  }\n  if (max === undefined) {\n    if (unsigned_long || signed_long || unsigned_fallback) max = 0x7FFFFFFF;\n  }\n  return {\n    get: function () {\n      var v = this._getattr(a.name);\n      var n = a.float ? parseFloat(v) : parseInt(v, 10);\n      if (v === null || !isFinite(n) || min !== undefined && n < min || max !== undefined && n > max) {\n        return def.call(this);\n      }\n      if (unsigned_long || signed_long || unsigned_fallback) {\n        if (!/^[ \\t\\n\\f\\r]*[-+]?[0-9]/.test(v)) {\n          return def.call(this);\n        }\n        n = n | 0; // jshint ignore:line\n      }\n\n      return n;\n    },\n    set: function (v) {\n      if (!a.float) {\n        v = Math.floor(v);\n      }\n      if (setmin !== undefined && v < setmin) {\n        utils.IndexSizeError(a.name + ' set to ' + v);\n      }\n      if (unsigned_long) {\n        v = v < 0 || v > 0x7FFFFFFF ? def.call(this) : v | 0; // jshint ignore:line\n      } else if (unsigned_fallback) {\n        v = v < 1 || v > 0x7FFFFFFF ? def.call(this) : v | 0; // jshint ignore:line\n      } else if (signed_long) {\n        v = v < -0x80000000 || v > 0x7FFFFFFF ? def.call(this) : v | 0; // jshint ignore:line\n      }\n\n      this._setattr(a.name, String(v));\n    }\n  };\n}\n\n// This is a utility function for setting up change handler functions\n// for attributes like 'id' that require special handling when they change.\nexports.registerChangeHandler = function (c, name, handler) {\n  var p = c.prototype;\n\n  // If p does not already have its own _attributeChangeHandlers\n  // then create one for it, inheriting from the inherited\n  // _attributeChangeHandlers. At the top (for the Element class) the\n  // _attributeChangeHandlers object will be created with a null prototype.\n  if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {\n    p._attributeChangeHandlers = Object.create(p._attributeChangeHandlers || null);\n  }\n  p._attributeChangeHandlers[name] = handler;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}